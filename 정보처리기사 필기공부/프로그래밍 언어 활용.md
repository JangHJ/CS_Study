# 4과목 : 프로그래밍 언어 활용

- **다음 C언어 프로그램이 실행되었을 때, 실행 결과1**
    
    ```jsx
    #include <stdio.h>
    int main(int args, char *argv[]){
    	int a = 5, b = 3, c = 12;
    	int t1, t2, t3;
    	t1 = a && b;
    	t2 = a || b;
    	t3 = !c;
    	printf("%d", t1 + t2 + t3);
    	return 0;
    }
    ```
    
    <문제 풀이>
    
    a && b → 1  AND연산자
    
    a || b → 1  OR연산자
    
    !c → 0  NOT연산자
    
    1 + 1 + 0 = **2**
    
    C언어 연산자에서는 0이 아닌 모든값은 1(TRUE)

<br>

- **다음 C언어 프로그램이 실행되었을 때, 실행 결과2**

    ```jsx
    #include <stdio.h>
    struct st{
    	int a;
    	int c[10];
    };
    
    int main(int args, char *argv[]){
    	int i = 0;
    	struct st ob1;
    	struct st ob2;
    	ob1.a = 0;
    	ob2.a = 0;
    
    	for(i=0; i<10; i++){
    		ob1.c[i] = i;
    		ob2.c[i] = ob1.c[i] + i;
    	}
    
    	for(i=0; i<10; i = i+2){
    		ob1.a[i] = ob1.a + ob1.c[i];
    		ob2.a[i] = ob2.a + ob2.c[i];
    	}
    
    	printf("%d", ob1.a + ob2.a);
    	return 0;
    }
    ```
    
    <문제 풀이>
    
    ob1.c[i] = i
    
    ob2.c[i] = i + i
    
    ob1.a = ob1.a + ob1.c[i]  =  0+2+4+6 + 8  = 20
    
    ob2.a = ob2.a + ob2.c[i]  =  0+4+8+12+16 = 40
    
    20 + 40 = 60

    <br>
    
**IP 프로토콜에서 사용하는 필드**

- Header Length는 IP 프로토콜의 헤더 길이를 32비트 워드 단위로 표시한다.
- Packet Length는 IP 헤더를 제외한 패킷 전체의 길이를 나타내며 최대 크기는 65,535 = 2^16 - 1)비트
- Time To Live는 송신 호스트가 패킷을 전송하기 전 네트워크에서 생존할 수 있는 시간을 지정한 것이다.
- Version Number는 IP 프로토콜의 버전번호를 나타낸다.

<br>

python 조건문 if, elif, else **else if 는 없음**

<br>

**RIP 라우팅 프로토콜**

- 최단 경로 탐색에는 Bellman-Ford 알고리즘을 사용하는 거리 벡터 라우팅 프로토콜
- 라우팅 프로토콜을 IGP와 EGP로 분류했을 때 IGP에 해당한다.
- 최단경로탐색에는 Bellman-Ford 알고리즘을 사용한다.
- 최적의 경로를 산출하기 위한 정보로서 홉(거리 값)만을 고려하므로, RIP을 선택한 경로가 최적의 경로가 아닌 경우가 많이 발생할 수 있다.
- 소규모 네트워크 환경에 적합하다.
- 최대 홉 카운트를 15홉 이하로 한정하고 있다.

<br>

**프로세스 스케줄링**

![프로세스 스케줄링](https://github.com/JangHJ/CS_Study/assets/13388283/22c66c79-658d-40ca-a572-1ebd00405901)


**HRN 스케줄링 방식**

- 비선점 스케줄링

실행시간이 긴 프로세스에 불리한 SJF 을 보완하기 위해 대기시간 및 서비스 시간을 이용

긴 작업과 짧은 작업 간의 지나친 불평등을 해소할 수 있다.

우선순위를 계산 숫자가 높은것부터 낮은순으로 순위 부여

(대기시간 + 서비스시간) / 서비스시간 = 우선순위값) 값이 클수록 우선순위가 높음.

<br>

**Python 데이터 타입 중 시퀀스(Sequence) 데이터 타입에 해당하며 다양한 데이터 타입들을 주어진 순서에 따라 저장할 수 있으나 저장된 내용을 변경할 수 없는 것**

리스트 타입 : 가변형

**튜플 타입** : 불변형

<br>

**IP 프로토콜의 주요 특징**

- 체크섬(Checksum) 기능으로 데이터 체크섬(Data Checksum)은 제공하지 않고, 헤더 체크섬만 제공함
- 패킷을 분할, 병합하는 기능을 수행하기도 한다.
- 비연결형 서비스를 제공한다.
- Best Effort 원칙에 따른 전송 기능을 제공한다.

<br>

**4개의 페이지를 수용할 수 있는 주기억장치가 있으며, 초기에는 모두 비어 있다고 가정한다. 다음의 순서로 페이지 참조가 발생할 때, LRU 페이지 교체 알고리즘을 사용할 경우 몇 번의 페이지 결함이 발생하는가?**

<문제 해설>LRU(Least Recently USed) 알고리즘

<br>

**사용자 수준에서 지원되는 스레드(thread)가 커널에서 지원되는 스레드에 비해 가지는 장점으로 옳은 것**

1. 한 프로세스가 운영체제를 호출할 때 전체 프로세스가 대기할 필요가 없으므로 시스템 성능을 높일 수 있다.
2. 동시에 여러 스레드가 커널에 접근할 수 있으므로 여러 스레드가 시스템 호출을 동시에 사용할 수 있다
3. 각 스레드를 개별적으로 관리할 수 있으므로 스레드의 독립적인 스케줄링이 가능하다.
4. 커널 모드로의 전환 없이 스레드 교환이 가능하므로 오버헤드가 줄어든다.

---

1,2,3 : 커널수준 스레드의 장점

**정답은 4번**

<br>

**모듈화(Modularity)와 관련한 설명으로 틀린 것**

1. 시스템을 모듈로 분할하면 각각의 모듈을 별개로 만들고 수정할 수 있기 때문에 좋은 구조가 된다.
2. 응집도는 모듈과 모듈 사이의 상호의존 또는 연관 정도를 의미한다.
3. 모듈 간의 결합도가 약해야 독립적인 모듈이 될 수 있다.
4. 모듈 내 구성 요소들 간의 응집도가 강해야 좋은 모듈 설계이다.

---

결합도: 모듈과 모듈 사이의 상호의존 또는 연관 정도를 의미한다.

응집도: 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미한다.

하나의 모듈이 하나의 기능을 수행하는 요소들간의 연관성 척도, 독립적인 모듈이 되기 위해서는 응집도가 강하고 결합도가 약해야함

**정답은 2번**

<br>
